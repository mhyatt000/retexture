"""Blender Code 9-25-23.ipynb
Automatically generated by Colaboratory.
Original file is located at
    https://colab.research.google.com/drive/1FyfPfq1_E7Xc3cs1sEw3CrQjyeJZLn_p
"""

import bpy
import os
import math

model_name= "modelName"
parent_file_path = "/Users/lukebaumel/Desktop/elephant2.dae"
output_directory = "/Users/lukebaumel/Desktop/automation1"
image_texture_path = "/Users/lukebaumel/Downloads/zebraTexture.jpg"
texture_name = "zebra"
model_name = "Elephant"
num_angles = 12
file_type = ".png"
object_name = "SketchUp"
numOfModels = 1
num = 0

for num in range(0, numOfModels+1):
  file_path = parent_file_path+model_name+str(num)+".dae" #elephant1, elephant2, elephant3
  #file_path = 1 #for loop that inputs the parent file path, concatenate with 1 and so on

  base_file_name = texture_name+model_name+str(num)

  load(num, file_path)
  uvUnwrap(image_texture_path)
  renderAndRotate (num_angles, object_name, base_file_name, file_type)
  bpy.data.objects[‘SketchUp’].select_set(state=True)
  bpy.ops.object.delete()

def load(num, file_path):
  if num > 0:
    # Import the Collada file
    bpy.ops.wm.collada_import(filepath=file_path)

  else:
    # Delete the default Cube object
    bpy.data.objects['Cube'].select_set(state=True)
    bpy.ops.object.delete()

def uvUnwrap(image_texture_path):
  # Select and join all mesh objects
  mesh_objects = [obj for obj in bpy.context.scene.objects if obj.type == 'MESH']
  for obj in mesh_objects:
    obj.select_set(state=True)
    bpy.context.view_layer.objects.active = mesh_objects[0]
    bpy.ops.object.join()

  # Unwrap the object using smart UV unwrap
  obj = bpy.context.active_object
  bpy.ops.object.mode_set(mode='EDIT')
  bpy.ops.uv.smart_project()
  bpy.ops.object.mode_set(mode='OBJECT')

# Convert Principled BSDF materials to Diffuse BSDF materials
  for slot, mat in enumerate(obj.material_slots):
      if mat.material.node_tree.nodes.get('Principled BSDF') is not None:
          principled_bsdf = mat.material.node_tree.nodes.get('Principled BSDF')
          diffuse_bsdf = mat.material.node_tree.nodes.new(type='ShaderNodeBsdfDiffuse')
          mat.material.node_tree.nodes.remove(principled_bsdf)
          mat.material.node_tree.links.new(diffuse_bsdf.outputs['BSDF'], mat.material.node_tree.nodes['Material Output'].inputs['Surface'])

  # Set the texture for Diffuse BSDF materials
  for slot, mat in enumerate(obj.material_slots):
      if mat.material.node_tree.nodes.get('Diffuse BSDF') is not None:
          diffuse_bsdf = mat.material.node_tree.nodes.get('Diffuse BSDF')
          image_texture = mat.material.node_tree.nodes.new(type='ShaderNodeTexImage')
          image_texture.image = bpy.data.images.load(image_texture_path)
          mat.material.node_tree.links.new(image_texture.outputs['Color'], diffuse_bsdf.inputs['Color'])

  # Switch to the UV Editing workspace
  uv_editing_workspace = bpy.data.workspaces.get("UV Editing")
  uv_editing_screen = uv_editing_workspace.screens.get("UV Editing")
  bpy.context.window.workspace = uv_editing_workspace

  # Select all elements in UV Editing
  if obj.type == 'MESH':
      bpy.ops.object.mode_set(mode='EDIT')
      bpy.ops.mesh.select_all(action='SELECT')
      bpy.ops.mesh.select_mode(type='FACE')
      bpy.ops.mesh.select_all(action='SELECT')
      bpy.ops.mesh.select_mode(type='EDGE')
      bpy.ops.mesh.select_all(action='SELECT')
      bpy.ops.mesh.select_mode(type='VERT')
      bpy.ops.object.mode_set(mode='OBJECT')

  # Unwrap the UVs
  bpy.ops.object.mode_set(mode='EDIT')
  if obj.type == 'MESH':
      bpy.ops.mesh.select_all(action='SELECT')
  bpy.ops.uv.smart_project()
  bpy.ops.object.mode_set(mode='OBJECT')

def renderAndRotate (num_angles, object_name, base_file_name, file_type):
  # Loop through each angle and render the image
  for i in range(num_angles):
      # Calculate the angle to rotate the object
      angle = i * (2*math.pi/num_angles)

      # Select the object to rotate
      obj = bpy.data.objects[object_name]

    # Set the camera location and lens settings
      bpy.context.scene.camera.location = (-32, -1, 10)  # Adjust the Z-coordinate as needed #4x the max value of the shape(?), height maybe 1.1x just as dimensions to try starting with. Want prooption to be fixed by the size of the model. #Length at the longest point ie xMax-xMin
      bpy.context.scene.camera.data.lens = 15  # Adjust the focal length as needed

      # Center the camera on the object
      bpy.ops.view3d.camera_to_view_selected() #outputs look like centering on center of mass, move camera way far back to see if centering gets better or worse. If better, center of mass issue is washed away

      # Set the rotation of the object
      obj.rotation_euler = (0, 0, angle)

      # Render the image
      bpy.ops.render.render(write_still=True)

      angleName = i * (360/num_angles)

      # Set the file name for the rendered image
      file_name = "{}_{}{}".format(base_file_name, angleName, file_type)

      # Save the rendered image to the output directory
      bpy.data.images['Render Result'].save_render(filepath=os.path.join(output_directory, file_name))

for num in range(0, 6):
  print(num)

import bpy
import os
import math

model_name= "elephant"
parent_file_path = "/Users/lukebaumel/Desktop/"
output_directory = "/Users/lukebaumel/Desktop/automation1"
image_texture_path = "/Users/lukebaumel/Downloads/zebraTexture.jpg"
texture_name = "zebra"
num_angles = 12
file_type = ".png"
object_name = "SketchUp"
numOfModels = 1
num = 1

def load(num, file_path):
  if num == 0:
     # Delete the default Cube object
    bpy.data.objects['Cube'].select_set(state=True)
    bpy.ops.object.delete()

  else:
    # Import the Collada file
    bpy.ops.wm.collada_import(filepath=file_path)

def uvUnwrap(image_texture_path):
  # Select and join all mesh objects
  mesh_objects = [obj for obj in bpy.context.scene.objects if obj.type == 'MESH']
  for obj in mesh_objects:
    obj.select_set(state=True)
    bpy.context.view_layer.objects.active = mesh_objects[0]
    bpy.ops.object.join()

  # Unwrap the object using smart UV unwrap
  obj = bpy.context.active_object
  bpy.ops.object.mode_set(mode='EDIT')
  bpy.ops.uv.smart_project()
  bpy.ops.object.mode_set(mode='OBJECT')

# Convert Principled BSDF materials to Diffuse BSDF materials
  for slot, mat in enumerate(obj.material_slots):
      if mat.material.node_tree.nodes.get('Principled BSDF') is not None:
          principled_bsdf = mat.material.node_tree.nodes.get('Principled BSDF')
          diffuse_bsdf = mat.material.node_tree.nodes.new(type='ShaderNodeBsdfDiffuse')
          mat.material.node_tree.nodes.remove(principled_bsdf)
          mat.material.node_tree.links.new(diffuse_bsdf.outputs['BSDF'], mat.material.node_tree.nodes['Material Output'].inputs['Surface'])

  # Set the texture for Diffuse BSDF materials
  for slot, mat in enumerate(obj.material_slots):
      if mat.material.node_tree.nodes.get('Diffuse BSDF') is not None:
          diffuse_bsdf = mat.material.node_tree.nodes.get('Diffuse BSDF')
          image_texture = mat.material.node_tree.nodes.new(type='ShaderNodeTexImage')
          image_texture.image = bpy.data.images.load(image_texture_path)
          mat.material.node_tree.links.new(image_texture.outputs['Color'], diffuse_bsdf.inputs['Color'])

  # Switch to the UV Editing workspace
  uv_editing_workspace = bpy.data.workspaces.get("UV Editing")
  uv_editing_screen = uv_editing_workspace.screens.get("UV Editing")
  bpy.context.window.workspace = uv_editing_workspace

  # Select all elements in UV Editing
  if obj.type == 'MESH':
      bpy.ops.object.mode_set(mode='EDIT')
      bpy.ops.mesh.select_all(action='SELECT')
      bpy.ops.mesh.select_mode(type='FACE')
      bpy.ops.mesh.select_all(action='SELECT')
      bpy.ops.mesh.select_mode(type='EDGE')
      bpy.ops.mesh.select_all(action='SELECT')
      bpy.ops.mesh.select_mode(type='VERT')
      bpy.ops.object.mode_set(mode='OBJECT')

  # Unwrap the UVs
  bpy.ops.object.mode_set(mode='EDIT')
  if obj.type == 'MESH':
      bpy.ops.mesh.select_all(action='SELECT')
  bpy.ops.uv.smart_project()
  bpy.ops.object.mode_set(mode='OBJECT')

def renderAndRotate (num_angles, object_name, base_file_name, file_type):
  # Loop through each angle and render the image
  for i in range(num_angles):
      # Calculate the angle to rotate the object
      angle = i * (2*math.pi/num_angles)

      # Select the object to rotate
      obj = bpy.data.objects[object_name]

    # Set the camera location and lens settings
      bpy.context.scene.camera.location = (-32, -1, 10)  # Adjust the Z-coordinate as needed #4x the max value of the shape(?), height maybe 1.1x just as dimensions to try starting with. Want prooption to be fixed by the size of the model. #Length at the longest point ie xMax-xMin
      bpy.context.scene.camera.data.lens = 15  # Adjust the focal length as needed

      # Center the camera on the object
      bpy.ops.view3d.camera_to_view_selected() #outputs look like centering on center of mass, move camera way far back to see if centering gets better or worse. If better, center of mass issue is washed away

      # Set the rotation of the object
      obj.rotation_euler = (0, 0, angle)

      # Render the image
      bpy.ops.render.render(write_still=True)

      angleName = i * (360/num_angles)

      # Set the file name for the rendered image
      file_name = "{}_{}{}".format(base_file_name, angleName, file_type)

      # Save the rendered image to the output directory
      bpy.data.images['Render Result'].save_render(filepath=os.path.join(output_directory, file_name))

for num in range(0, numOfModels+1):
  file_path = parent_file_path+model_name+str(num)+".dae" #elephant1, elephant2, elephant3
  #file_path = 1 #for loop that inputs the parent file path, concatenate with 1 and so on

  base_file_name = texture_name+model_name+str(num)

  load(num, file_path)
  uvUnwrap(image_texture_path)
  renderAndRotate (num_angles, object_name, base_file_name, file_type)
  bpy.data.objects["SketchUp"].select_set(state=True)
  bpy.ops.object.delete()
